{
    "body": "### Summary\r\n\r\nLet's make Spack be able to recognize spack installs for externals.  We parse a lot of the information for the builds/package  into a json file that gets included in every install (environments, views, opt, etc).  As a user I would like to be able to use `spack external` to get externals from other users spack instances by pointing to a spack  environment or view they've created.\r\n\r\n@tgamblin @becker33 @scheibelp @haampie @alalazo \r\n\r\n### Rationale\r\n\r\nIt's no secret that people want to re-use binaries and not keep re-building them.  Spack has several elegant ways of addressing this:\r\n\r\n- Upstreams\r\n- `--reuse`\r\n- Binary Caches\r\n- Externals\r\n\r\nThe issue I have with the first 3 is they all rely on the concretizer to choose the \"best\" version of the software for me.\r\nHowever, in the development workflow I often want explicit control over which binaries I am using.\r\n\r\nSome examples: \r\n\r\n- developer a is developing an upstream dependency and wants developer b to test it.  Sure developer b can re-build, but why not just link against their installation in the first place?\r\n- I want to store time stamped releases of my software and link against them. The spack package is not changing so the hash isn't likely to change.  Should I need to create a new instance of spack every time I want to upstream this, and then swap out my upstreams? Same question for binary caches?\r\n\r\nI think there is a fundamental weakness in the first 3 ways of including previous builds: they all rely on the concretizer to pick you binaries for you.\r\n\r\nThis is where externals seems like a perfect fit, but they have long been a dark horse for Spack. This is because they are typicaly used for system installed packages which Spack has no idea about.\r\n\r\nHowever, I propose that `spack external --path [foo]` when pointed to:\r\n\r\n1. A valid Spack environment\r\n2. A valid Spack view\r\n\r\nshould be able to generate externals that the concretizer can handle, and spack can use as efficiently as an upstream or binary cache.\r\n\r\n### Description\r\n\r\nI would like to be able to run `spack external --path /path/to/spack/view-or-env` with options to blacklist or whitelist packages. A bonus feature would be the ability to dump to a file instead of automatically including them in my `spack.yaml` or `packages.yaml`.\r\n\r\nWe've prototyped this as part of [Spack-Manager](https://github.com/psakievich/spack-manager) with the following interface:\r\n```console\r\nspack manager external --help\r\nusage: spack manager external [-hm] [-n NAME] [-v VIEW] [-w [WHITELIST ...] | -b [BLACKLIST ...]] [--latest] [--list] [path]\r\n\r\npositional arguments:\r\n  path                  The location of the external install directory\r\n\r\noptional arguments:\r\n  --latest              use the latest snapshot available\r\n  --list                print a list of the available externals to use.\r\n                        Values in parenthesis are the view names for each external\r\n  -b [BLACKLIST ...], --blacklist [BLACKLIST ...]\r\n                        (not implemented) specs that should be omitted (add all others)\r\n  -h, --help            show this help message and exit\r\n  -m, --merge           merge existing yaml files together\r\n  -n NAME, --name NAME  name the new include file for the externals with this name\r\n  -v VIEW, --view VIEW  name of view to use in the environment.\r\n                        This will default to the first view in the environment\r\n                        i.e. the first view listed in \"spack manager external --list\" command\r\n  -w [WHITELIST ...], --whitelist [WHITELIST ...]\r\n                        (not implemeted) specs that should be added (omit all others)\r\n```\r\n\r\nOur version only works with environment that have packages partitioned into views.  And it only writes externals to an `externals.yaml` file which is where the `--merge` flag comes from.  I would really like to extend this feature to views and make it something that is functional in mainline Spack, but I will likely need help from the core development team to get it worked out. I have a very limited number of cycles for Spack development right now due to other project work.\r\n\r\n### Additional information\r\n\r\nThe source code for the Spack-Manager implementation is here: \r\nhttps://github.com/psakievich/spack-manager/blob/main/spack-scripting/scripting/cmd/manager_cmds/external.py.\r\n\r\n\r\nOur implementation also currently suffers from limitations in Clingo to concretize the spack spec's we write to file, and so we must use the original concretizer.  See #28201\r\n\r\n### General information\r\n\r\n- [X] I have run `spack --version` and reported the version of Spack\r\n- [X] I have searched the issues of this repo and believe this is not a duplicate",
    "user": "psakievich",
    "url": "https://api.github.com/repos/spack/spack/issues/29315",
    "updated_at": "2022-03-03 20:00:48",
    "created_at": "2022-03-03 13:10:35",
    "closed_at": "None",
    "state": "open",
    "title": "Create the ability for Spack to recognize Spack installs for externals",
    "number": 29315,
    "milestone": null,
    "labels": [
        "feature"
    ],
    "id": 1158391563,
    "html_url": "https://github.com/spack/spack/issues/29315",
    "assignees": [],
    "comments": 0
}