{
    "body": "Fixes #3478.\r\nFixes #3594.\r\nFixes #4051.\r\n\r\n## Motivation\r\n\r\nPython installations are both important and unfortunately inconsistent. Depending on the Python version, OS, and the strength of the Earth's magnetic field when it was installed, the name of the Python executable, directory containing its libraries, library names, and the directory containing its headers can vary drastically. \r\n\r\nI originally got into this mess with #3274, where I discovered that Boost could not be built with Python 3 because the executable is called `python3` and we were telling it to use `python`. I got deeper into this mess when I started hacking on #3140, where I discovered just how difficult it is to find the location and name of the Python libraries and headers.\r\n\r\nCurrently, half of the packages that depend on Python and need to know this information jump through hoops to determine the correct information. The other half are hard-coded to use `python`, `spec['python'].prefix.lib`, and `spec['python'].prefix.include`. Obviously, none of these packages would work for Python 3, and there's no reason to duplicate the effort. The Python package itself should contain all of the information necessary to use it properly. This is in line with the recent work by @alalazo and @davydden with respect to `spec['blas'].libs` and friends.\r\n\r\n## Prefix\r\n\r\nFor most packages in Spack, we assume that the installation directory is `spec['python'].prefix`. This generally works for anything installed with Spack, but gets complicated when we include external packages. Python is a commonly used external package (it needs to be installed just to run Spack). If it was installed with Homebrew, `which python` would return `/usr/local/bin/python`, and most users would erroneously assume that `/usr/local` is the installation directory. If you peruse through #2173, you'll immediately see why this is not the case. Homebrew actually installs Python in `/usr/local/Cellar/python/2.7.12_2` and symlinks the executable to `/usr/local/bin/python`. `PYTHONHOME` (and presumably most things that need to know where Python is installed) needs to be set to the actual installation directory, not `/usr/local`.\r\n\r\nNormally I would say, \"sounds like user error, make sure to use the real installation directory in your `packages.yaml`\". But I think we can make a special case for Python. That's what we decided in #2173 anyway. If we change our minds, I would be more than happy to simplify things.\r\n\r\nTo solve this problem, I created a `spec['python'].home` attribute that works the same way as `spec['python'].prefix` but queries Python to figure out where it was actually installed. @tgamblin Is there any way to overwrite `spec['python'].prefix`? I think it's currently immutable.\r\n\r\n## Command\r\n\r\nIn general, Python 2 comes with both `python` and `python2` commands, while Python 3 only comes with a `python3` command. But this is up to the OS developers. For example, `/usr/bin/python` on Gentoo is actually Python 3. Worse yet, if someone is using an externally installed Python, all 3 commands may exist in the same directory! Here's what I'm thinking:\r\n\r\nIf the spec is for Python 3, try searching for the `python3` command.\r\nIf the spec is for Python 2, try searching for the `python2` command.\r\nIf neither are found, try searching for the `python` command.\r\n\r\n## Libraries\r\n\r\nSpack installs Python libraries in `spec['python'].prefix.lib`. Except on openSUSE 13, where it installs to `spec['python'].prefix.lib64` (see #2295 and #2253). On my CentOS 6 machine, the Python libraries are installed in `/usr/lib64`. Both need to work.\r\n\r\nThe libraries themselves change name depending on OS and Python version. For Python 2.7 on macOS, I'm seeing:\r\n```\r\nlib/libpython2.7.dylib\r\n```\r\nFor Python 3.6 on CentOS 6, I'm seeing:\r\n```\r\nlib/libpython3.so\r\nlib/libpython3.6m.so.1.0\r\nlib/libpython3.6m.so -> lib/libpython3.6m.so.1.0\r\n```\r\nNotice the `m` after the version number. Yeah, that's a thing.\r\n\r\n## Headers\r\n\r\nIn Python 2.7, I'm seeing:\r\n```\r\ninclude/python2.7/pyconfig.h\r\n```\r\nIn Python 3.6, I'm seeing:\r\n```\r\ninclude/python3.6m/pyconfig.h\r\n```\r\nIt looks like all Python 3 installations have this `m`. Tested with Python 3.2 and 3.6 on macOS and CentOS 6\r\n\r\nSpack has really nice support for libraries (`find_libraries` and `LibraryList`), but nothing for headers. Fixed.\r\n\r\n## Reviewing\r\n\r\nThis is obviously a big change, and will need thorough testing. I'm looking at the following people for reviews:\r\n\r\n@alalazo @davydden I believe you did most of the existing work on `LibraryList` and `find_libraries`. Can you make sure my header-equivalents look solid?\r\n@citibeth You're one of the few Spack users who makes heavy use of Python 3. Can you check that things work?\r\n@BarrySmith You went through hell to get Spack working for your Homebrew-installed Python. Can you confirm that my changes still work the way you need?\r\n@mdavezac You got me into this mess. Can you test Boost for me?",
    "user": "adamjstewart",
    "url": "https://api.github.com/repos/spack/spack/issues/3367",
    "updated_at": "2017-11-12 00:49:17",
    "created_at": "2017-03-04 22:53:24",
    "closed_at": "2017-04-30 00:24:14",
    "state": "closed",
    "title": "Python command, libraries, and headers",
    "number": 3367,
    "milestone": "v0.11.0",
    "labels": [
        "python",
        "ready",
        "dependencies",
        "external-packages"
    ],
    "id": 211914608,
    "html_url": "https://github.com/spack/spack/pull/3367",
    "assignees": [],
    "comments": 44
}