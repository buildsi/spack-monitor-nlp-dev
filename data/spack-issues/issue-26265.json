{
    "body": "We currently have three different ways to load packages \"at runtime\":\r\n\r\n1. `spack load` \r\n2. `spack env activate`\r\n3. `module load`\r\n\r\nall of which have different behaviors. The idea of this proposal is to ensure they all\r\nhave the same semantics by default, but still allow them to be configurable in ways\r\nthat make sense for certain centers (in particular w.r.t. module files).\r\n\r\nAs similar command is `spack build-env`, but this proposal is targeted towards installed\r\nspecs and how to interact with them as a user, not as a developer.\r\n\r\n## What does \"loading a package/spec\" currently mean?\r\n\r\nWe're calling `spack.user_environment.environment_modifications_for_spec`, which more or\r\nless does the following:\r\n\r\n1. Add `prefix_inspections`:\r\n   Prepends the (subdir of the) spec prefix to `PATH`, `CMAKE_PREFIX_PATH` etc as\r\n   specified by the user in their `modules.yaml`.\r\n2. Add `modifications_from_dependencies` in a *run*-context:\r\n   From the docstring it \"returns the environment modifications that are required by the\r\n   dependencies of a spec and also applies modifications to this spec's package at\r\n   module scope.\"\r\n   This code is very hard to follow and more targeted towards build/test context than\r\n   run context, my TL;DR version:\r\n   1. For *all transient run-type deps*: it adds `<prefix>/bin[64]` to the PATH.\r\n   2. For *all transient link-and-run-type deps* it calls:\r\n      a. `set_module_variables_for_package`\r\n         (This defines props on the dependency, like `make`, `ninja`, # build jobs, \r\n          cmake standard args, `spack_cc` executable, ... all related to builds.)\r\n      b. `setup_dependent_package`\r\n         (This makes the dependency set a bunch of props on the current package or on\r\n          the dep itself, usually used as `self.spec.mpicc = xyz`, so the dependent can\r\n          use that during the build)\r\n      c. `setup_dependent_run_environment`\r\n         (This is used to make the dependency modify env variables that may depend on\r\n          the dependent = current package's spec. E.g. if py-x is loaded and it depends\r\n          on Python, then the Python package iterates over all depedencies of py-x to\r\n          find more python packages, and adds those paths to `PYTHONPATH`.)\r\n      \r\n      It does **not** call `setup_run_environment` on these transient dependencies.\r\n\r\n## What packages are loaded by default without changing config?\r\n\r\n1. `spack load x y z` collects *all transient dependencies of any type* of CLI specs and\r\n   loads these packages individually.\r\n2. `spack env activate env` collects *all transient run-type dependencies of all env\r\n   root specs* and loads these packages individually.\r\n3. `module load x y z` *only* loads the CLI-provided specs.\r\n\r\n## What are the current problems with loading?\r\n\r\nShort version:\r\n\r\na. Inconsistent behavior (as outlined above)\r\nb. Risk of broken module files by default\r\nc. Bad performance\r\nd. `setup_dependent_run_environment` is more of a hack to patch module files\r\n\r\n\r\n**Module files issues**\r\n   Runtime package loading *requires* specs of transient run-type to be loaded.\r\n   \r\n   Loading run-type dependencies shouldn't be interpreted weakly like putting\r\n   `<prefix>/bin` in the path, but rather: it requires\r\n   `Package::setup_[dependendent_]run_environment` to be called on all transient\r\n   run-type deps, since the package knows/defines what is necessary at runtime apart\r\n   from the sensible defaults Spack or the user sets in `prefix_inspections`.\r\n\r\n   Our generated module files do not contain the modifications from\r\n   `setup_run_environment`, only `setup_dependent_run_environment`. If you have `A`\r\n   depends on `B` depends on `C` all with run deptype, then by default,\r\n   `module load A` loads `A` but not `B` or `C`.\r\n\r\n   You get false impressions from `module load py-xyz`: module files for Python\r\n   packages usually work, not because we recursively load run-type deps, but because\r\n   the Python packages sets `PYTHONPATH` for all run-type deps in\r\n   `setup_dependent_run_environment`. However, a correct `PYTHONPATH` is not enough, it\r\n   is still required to call `setup_run_environment` on every dependency, and Python\r\n   packages that specify an elaborate setup there are broken as dependencies when using\r\n   `module load`.\r\n\r\n   If we would make `setup_dependent_run_environment` call `setup_run_environment`, we\r\n   effectively get working self-contained module files, but then we also run\r\n   `setup_run_environment` twice in `spack load` / `spack env activate` for all\r\n   packages.\r\n\r\n   Note that Python packages can easily work without `setup_dependent_run_environment`,\r\n   if they just set add their `PYTHONPATH` in `setup_run_environment`, which can be\r\n   done in the base class Python packages inherit. For modules to work though, this\r\n   implies that all run-type dependencies are auto-loaded.\r\n\r\n**Unclear what goes into `setup_dependent_run_environment` / `setup_run_environment`**\r\n   For the user it is in fact unclear when to use `setup_dependent_run_environment` vs\r\n   `setup_run_environment`, and often you see packages implement both with duplicated\r\n   contents, without the dependent spec from `setup_dependent_run_environment` being\r\n   used.\r\n\r\n**Performance issues**\r\n   Loading the runtime environment should be super fast, which is the case with module\r\n   files as they are mostly static, but not the case with `spack load`,\r\n   `spack env activate`, and generating module files.\r\n\r\n   `spack load` clearly loads too many packages, it makes more sense to stick to\r\n   loading the roots + transient run-type deps only, just like in `spack env activate`.\r\n\r\n   `spack env activate` is slow because it lists all run-type packages, and then loads\r\n   each of them individually, which recurses into their dependencies, leading to `n^2`\r\n   visits of all packages if there's a chain of `n` of them. Instead, we should be able\r\n   to visit each package once during a load.\r\n\r\n   Every Python package in the DAG will call `setup_dependent_run_environment` on\r\n   Python itself, which traverses the dependencies again. This is yet another redundant\r\n   traversal of all packages. We can delegate `setup_dependent_run_environment` to\r\n   each package's `setup_run_environment` instead. Similar issues exist for R, Perl,\r\n   Java, ... packages -- they can be fixed on the package level itself.\r\n\r\n   Loading does a lot of calls to EnvironmentModifications methods, which unwind the\r\n   stracktrace to keep track of what packages modify what, which is useful in builds\r\n   to warn the user that a package by-passes Spack's compiler wrappers. For run-time\r\n   loading of already installed packages this makes no sense, and it's a huge\r\n   performance killer.\r\n\r\n   Runtime loading still sets up all packages as if they were going to be built. In\r\n   particular:\r\n   1. `set_module_variables_for_package`\r\n   2. `setup_dependent_package` (I've only seen it used in a build context)\r\n\r\n## Proposal\r\n\r\nTo make our lives easier and to make users know what to expect, we should fix the\r\ninconsistencies between the defaults `spack load`, `spack env activate` and\r\n`module load`.\r\n\r\n### Recursive module loading by default\r\nMost controversial, I would want to suggest to make `module load` autoload its run-type*\r\ndeps by default. This way, every module file contains the environment changes for its\r\nSpack package and no more. So the module file for `py-xyz` appends its prefix to the\r\n`PYTHONPATH` (done by `setup_run_environment`) but not those of its dependencies.\r\n\r\nThis is well supported by `lmod`, since it has `depends_on` and does proper reference\r\ncounting of loaded modules. It seems very useful and trivial to enable in Spack.\r\n\r\nFor `tcl`, autoloading support is somewhat hacky, but we have it, it's just that there's\r\nno refcounting. Users can still disable autoloading, and instead module load everything\r\nby hand -- but clearly with Python packages that'd be unmanageable. We *could* support\r\nmodule files that basically \"inline\" the `depends_on`'s that lmod uses, so that you have\r\n1 module file which contains all changes for all transient dependencies, but this looks\r\nsomewhat questionable.\r\n\r\n\\* Note: currently it also loads link-type deps by default -- do we need that? Don't we have rpath?\r\n\r\nTo be figured out: should external (cray) modules be `depends_on`'d?\r\n\r\n### Loading should not require any build related changes\r\n\r\nI'm reasonably confident that `setup_dependent_package` is only used in a build context\r\nto modify a Spec to make executables available. It'd be nice to skip it. Also we could\r\ndrop `set_module_variables_for_package`, it's very build-related.\r\n\r\n### No more `setup_dependent_run_environment`\r\n\r\nI think `setup_dependent_run_environment` is redundant. It's causing performance\r\nregressions because of walking the DAG excessively in Python/R/etc packages,\r\nand it is used to insert environment changes in the parent module file -- but this is\r\nno long necessary when we do autoloading. Finally it's confusing users and we see many\r\npackages just duplicating `setup_run_environment` in `setup_dependent_run_environment`,\r\nsince it's unclear in what context each is used.\r\n\r\n### Visiting packages to be loaded once in a deterministic order\r\n\r\nWhen running `spack load x y z` or `spack env activate env` with `[x, y, z]` the root\r\nspecs, and `setup_dependent_run_environment` + `setup_dependent_package` +\r\n`set_module_variables_for_package` removed or dropped as requirements for runtime\r\nloading, we can in fact collect the unique list of roots with transient run-type deps\r\nahead of time in a sensible order (post-order with @scheibelp's pessimisation of\r\nexternals), loop over them *once*, and call `prefix_inspections` and\r\n`setup_run_environment` once, and call it a day.",
    "user": "haampie",
    "url": "https://api.github.com/repos/spack/spack/issues/26265",
    "updated_at": "2021-09-27 14:06:38",
    "created_at": "2021-09-27 14:00:59",
    "closed_at": "2021-09-27 14:06:38",
    "state": "closed",
    "title": "Proposal for loading packages in Spack",
    "number": 26265,
    "milestone": null,
    "labels": [
        "feature"
    ],
    "id": 1008189561,
    "html_url": "https://github.com/spack/spack/issues/26265",
    "assignees": [],
    "comments": 0
}