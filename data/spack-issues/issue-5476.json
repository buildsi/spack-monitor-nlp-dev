{
    "body": "Addresses an issue that came up in #4907.\r\n\r\nA package can now depend on a special patched version of its dependencies. \r\n\r\n  - [x] `depends_on()` can optionally take a patch directive or a list of them:\r\n\r\n    ```python\r\n         depends_on(<spec>,\r\n                    patches=patch(..., when=<cond>),    # condition on dependency\r\n                    when=<cond>)                        # condition on this package\r\n         # or\r\n         depends_on(<spec>,\r\n                    patches=[patch(..., when=<cond>),   # condition on dependency\r\n                             patch(..., when=<cond>)],  # condition on dependency\r\n                    when=<cond>)                        # condition on this package\r\n    ```\r\n\r\n  - [x] The `Spec` YAML (and therefore the hash) now includes the sha256 of\r\n    the patch in the `Spec` YAML, which changes its hash.\r\n      - The special patched version will be built separately from a \"vanilla\"\r\n        version of the same package.\r\n      - This allows packages to maintain patches on their dependencies\r\n        without affecting either the dependency package or its dependents.\r\n        This could previously be accomplished with special variants, but\r\n        having to add variants means the hash of the dependency changes\r\n        frequently when it really doesn't need to.  This commit allows the\r\n        hash to change *just* for dependencies that need patches.\r\n      - Patching dependencies shouldn't be the common case, but some packages\r\n        (qmcpack, hpctoolkit, openspeedshop) do this kind of thing and it\r\n        makes the code structure mirror maintenance responsibilities.\r\n\r\n  - [x] This commit means that adding or changing a patch on a\r\n    package will change its hash.  This is probably what *should* happen,\r\n    but we haven't done it so far. (@adamjstewart mentioned some ANL\r\n    folks wanting this)\r\n      - Only applies to `patch()` directives; `package.py` files (and their\r\n        `patch()` functions) are not hashed, but we'd like to do that in the\r\n        future.\r\n\r\n  - [x] To implement these extensions to Spack's DSL, some fanciness was added to\r\n      `directives.DirectiveMetaMixin`.  In particular:\r\n      - directives can be nested (called as parameters to other directives) and their \r\n        results won't be enqueued for lazy execution like a normal directive.\r\n      - same for directives called within directives\r\n\r\n  - [x] Previously, the `patch()` directive only took an `md5` parameter.  Now\r\n    it takes a `sha256` parameter.  We restrict the hash used because we want\r\n    to be consistent about which hash is used in the `Spec`.\r\n      - A side effect of hashing patches is that *compressed* patches fetched\r\n        from URLs now need *two* checksums: one for the downloaded archive and\r\n        one for the content of the patch itself.  Patches fetched uncompressed\r\n        only need a checksum for the patch.  Rationale:\r\n      - we include the content of the *patch* in the spec hash, as that is\r\n        the checksum we can do consistently for patches included in Spack's\r\n        source and patches fetched remotely, both compressed and\r\n        uncompressed.\r\n      - we *still* need the patch of the downloaded archive, because we want\r\n        to verify the download *before* handing it off to tar, unzip, or\r\n        another decompressor.  Not doing so is a security risk and leaves\r\n        users exposed to any arbitrary code execution vulnerabilities in\r\n        compression tools.\r\n\r\n- [x] This also refactors the way dependency metadata is stored on packages.\r\n  - Previously, dependencies and dependency_types were stored as separate\r\n    dicts on Package.  This means a package can only depend on another in one \r\n    specific way, which is usually but not always true.\r\n  - Prior code unioned dependency types statically across dependencies on\r\n    the same package.\r\n  - New code stores dependency relationships as their own object (a `Dependency`),\r\n      with a spec constraint and a set of dependency types and patches per relationship.\r\n      - Dependency types are now more precise\r\n      - There is now room to add more information to dependency relationships (like patches)\r\n  - New `Dependency` class lives in `spack.dependency`, along with deptype\r\n    definitions that used to live in `spack.spec`.\r\n\r\n  - [x] Updated `nwchem` and `nauty` to use `sha256` for patches (@junghans)\r\n\r\n  - [x] Lines with long checksums are now ignored by `spack flake8`\r\n\r\n- [x] Documentation\r\n\r\n@naromero77: this is nearly done, and should let you continue to maintain your own patches on dependencies for `qmcpack`.\r\n\r\n@jgalarowicz: you may be interested in this for `openspeedshop`.\r\n@mwkrentel: you may be interested in this for `hpctoolkit`, too, as I know you maintain a lot of patches on your dependencies.  This would allow you to maintain them with the `hpctoolkit` package wtihout disrupting other packages.",
    "user": "tgamblin",
    "url": "https://api.github.com/repos/spack/spack/issues/5476",
    "updated_at": "2017-11-12 00:47:15",
    "created_at": "2017-09-26 09:36:01",
    "closed_at": "2017-09-30 09:07:01",
    "state": "closed",
    "title": "Packages can require patches on dependencies",
    "number": 5476,
    "milestone": "v0.11.0",
    "labels": [
        "specs",
        "dependencies",
        "patch"
    ],
    "id": 260556699,
    "html_url": "https://github.com/spack/spack/pull/5476",
    "assignees": [],
    "comments": 8
}