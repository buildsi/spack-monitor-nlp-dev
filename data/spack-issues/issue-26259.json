{
    "body": "Supersedes #26048, #25557.\r\nCloses #25380.\r\nFixes #8703.\r\n\r\nThird time's a charm?\r\n\r\nThis is a simpler take on converting `cc` to posix shell. The rationale for doing this can be found in https://github.com/spack/spack/pull/25380#issuecomment-903336139 and above.\r\n\r\n#26048 worked, but the main issue there was that the code used a lot of command substitution with `$()`, which unfortunately runs in a subshell.  That requires a lot of forks, which are expensive, which is why we saw a lot of slowdowns with the POSIX wrappers in that PR.\r\n\r\n## Design\r\n\r\nThis version tries to be as straightforward as possible.  Specifically, most conversions are kept simple -- convert ifs to ifs, handle indirect expansion the way we do in `setup-env.sh`, only mess with the logic in `cc`, and don't mess with the python code at all.\r\n\r\nThe big refactor is for arrays. We can't rely on bash's nice arrays and be ignorant of separators anymore. So:\r\n\r\n1. To avoid complicated separator logic, there are three types of lists. They are:\r\n    * `$lsep`-separated lists, which end with `_list`.  `lsep` is customizable, but we picked `^G` (alarm bell) for `$lsep` because it's ASCII and it's unlikely that it would actually appear in any arguments. If we need to get fancier (and I will lose faith in the world if we do) then we could consider XON or XOFF.\r\n    * `:`-separated directory lists, which end with `_dirs`, `_DIRS`, `PATH`, or `PATHS`\r\n    * whitespace-separated lists (like flags), which can have any other name\r\n  \r\n    Whitespace and colon-separated lists come with the territory with PATHs from env vars and lists of flags. `^G` separated lists are what we use for most internal variables, b/c it's more likely to work.\r\n2. To avoid subshells, use a bunch of functions that do dirty `eval` stuff instead.  This adds 3 functions to deal with lists:\r\n    * `append LISTNAME ELEMENT [SEP]`  will put `ELEMENT` at the end of the list called `LISTNAME`. You can optionally say what separator you expect to use. Note that we are taking advantage of everything being global and passing lists by name.\r\n    * `prepend LISTNAME ELEMENT [SEP]`  like append, but puts `ELEMENT` at the start of `LISTNAME`\r\n    *  `extend LISTNAME1 LISTNAME2 [PREFIX]` appends everything in LISTNAME2 to LISTNAME1, and optionally prepends `PREFIX` to every element (this is useful for things like `-I`, `-isystem `, etc.\r\n\r\nThe routines determine the separator for each argument by its name, so we don't have to pass around separators everywhere. Amazingly, as long as you do not expand variables' values within an `eval` environment, you can do all this and still preserve quoting. When iterating over lists, the user of this API still has to set and unset `IFS` properly.\r\n\r\nWe ended up having to ignore shellcheck SC2034 (unused variable), because using evals all over the place means that shellcheck doesn't notice that our list variables are actually used.\r\n\r\n## Performance\r\n\r\nSo far this is looking pretty good.  I took the most complex unit test I could find to measure the performance of just the `cc` script.  It's here if you want to see it.\r\n\r\n<details>\r\n<summary>`test_cc.sh`: a moderately complex test script for `cc`</summary>\r\n<p>\r\n\r\n```shell\r\n#!/bin/sh\r\n\r\nexport SPACK_TEST_COMMAND=dump-args\r\n\r\nexport SPACK_CC='/bin/mycc'\r\nexport SPACK_CXX='/bin/mycc'\r\nexport SPACK_FC='/bin/myfc'\r\nexport SPACK_PREFIX='/spack-test-prefix'\r\nexport SPACK_ENV_PATH='test'\r\nexport SPACK_DEBUG_LOG_DIR='.'\r\nexport SPACK_DEBUG_LOG_ID='foo-hashabc'\r\nexport SPACK_COMPILER_SPEC='gcc@4.4.7'\r\nexport SPACK_SHORT_SPEC='foo@1.2 arch=linux-rhel6-x86_64 /hashabc'\r\nexport SPACK_SYSTEM_DIRS='/bin:/usr/bin:/usr/local/bin:/bin64:/usr/bin64:/usr/local/bin64:/include:/usr/include:/usr/local/include:/lib:/usr/lib:/usr/local/lib:/lib64:/usr/lib64:/usr/local/lib64:/:/usr:/usr/local'\r\nexport SPACK_CC_RPATH_ARG='-Wl,-rpath,'\r\nexport SPACK_CXX_RPATH_ARG='-Wl,-rpath,'\r\nexport SPACK_F77_RPATH_ARG='-Wl,-rpath,'\r\nexport SPACK_FC_RPATH_ARG='-Wl,-rpath,'\r\nexport SPACK_LINK_DIRS=''\r\nexport SPACK_INCLUDE_DIRS=''\r\nexport SPACK_RPATH_DIRS=''\r\nexport SPACK_TARGET_ARGS=''\r\nexport SPACK_LINKER_ARG='-Wl,'\r\nexport SPACK_DTAGS_TO_ADD='--disable-new-dtags'\r\nexport SPACK_DTAGS_TO_STRIP='--enable-new-dtags'\r\n\r\n\r\nexport SPACK_CPPFLAGS='-g -O1 -DVAR=VALUE'\r\nexport SPACK_CFLAGS='-Wall'\r\nexport SPACK_CXXFLAGS='-Werror'\r\nexport SPACK_FFLAGS='-w'\r\nexport SPACK_LDFLAGS='-L foo'\r\nexport SPACK_LDLIBS='-lfoo'\r\n\r\nenv=\"/Users/gamblin2/src/spack/lib/spack/env\"\r\ncc=\"$env/cc\"\r\nld=\"$env/ld\"\r\n\r\n$ld '-I/test/include' '-L/test/lib' '-L/other/lib' '-I/other/include' 'arg1' '-Wl,--start-group' 'arg2' '-Wl,-rpath,/first/rpath' 'arg3' '-Wl,-rpath' '-Wl,/second/rpath' '-llib1' '-llib2' 'arg4' '-Wl,--end-group' '-Xlinker' '-rpath' '-Xlinker' '/third/rpath' '-Xlinker' '-rpath' '-Xlinker' '/fourth/rpath' '-Wl,--rpath,/fifth/rpath' '-Wl,--rpath' '-Wl,/sixth/rpath' '-llib3' '-llib4' 'arg5' 'arg6' '-loopopt=0'\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\nUsing that, I can time ~200 invocations of cc like this:\r\n\r\n```console\r\n$ bash -c 'time (for i in `seq 1 200`; do ~/test_cc.sh > /dev/null; done)'\r\n```\r\n\r\nUsing that, I get the following performance numbers (the listed shells are what I put in `cc`'s shebang):\r\n\r\n**Original**\r\n* Old version of `cc` with arrays and `bash v3.2.57` (macOS builtin): `4.462s` (`.022s` / call)\r\n* Old version of `cc` with arrays and `bash v5.1.8` (Homebrew): `3.267s` (`.016s` / call)\r\n\r\n**Using many subshells (#26408)**\r\n*  with `bash v3.2.57`: `25.302s` (`.127s` / call)\r\n*  with `bash v5.1.8`: `27.801s` (`.139s` / call)\r\n*  with `dash`: `15.302s` (`.077s` / call)\r\n\r\nThis version didn't seem to work with zsh.\r\n\r\n**This PR (no subshells)**\r\n*  with `bash v3.2.57`: `4.973s` (`.025s` / call)\r\n*  with `bash v5.1.8`: `4.984s` (`.025s` / call)\r\n*  with `zsh`: `2.995s` (`.015s` / call)\r\n*  with `dash`: `1.890s` (`.0095s` / call)        \u2b05\ufe0f **Easily the winner** \ud83e\udd47\r\n\r\nSo there are several interesting things to note here:\r\n\r\n1. Running the posix version in `bash` is slower than using `bash` arrays.  That is to be expected because it's doing a bunch of string processing where it likely did not have to before, at least in `bash`.\r\n2. `zsh`, at least on macOS, is significantly faster than the ancient `bash` they ship with the system. Using `zsh` with the new version also makes the posix wrappers faster than `develop`.  So it's worth preferring `zsh` if we have it.  I suppose we should also try this with newer `bash` on Linux.\r\n3. `bash v5.1.8` seems to be significantly faster than the old system `bash v3.2.57` for arrays. For straight POSIX stuff, it's a little slower.  It did not seem to matter whether `--posix` was used.\r\n4. `dash` is way faster than `bash` or `zsh`, so the real payoff just comes from being able to use it. I am not sure if that is mostly startup time, but it's significant. `dash` is ~2.4x faster than the original `bash` with arrays.\r\n\r\nSo I guess I may be proven wrong by @adamjstewart - I was right that doing a lot of string stuff is slower than arrays, but converting to posix seems worth it to be able to exploit `dash`.\r\n\r\n- [x] Fix basic shellcheck issues\r\n- [x] Convert arrays to use a few convenience functions: `append` and `extend`\r\n- [x] Get `cc` tests passing.\r\n- [x] More tests\r\n- [x] Get this working with `gettext`'s `configure` and test on more packages.",
    "user": "tgamblin",
    "url": "https://api.github.com/repos/spack/spack/issues/26259",
    "updated_at": "2021-10-05 01:30:22",
    "created_at": "2021-09-27 08:40:36",
    "closed_at": "2021-10-05 01:30:21",
    "state": "closed",
    "title": "cc: posix shell compiler wrappers -- take three",
    "number": 26259,
    "milestone": null,
    "labels": [
        "compilers",
        "build-environment",
        "tests",
        "shell-support",
        "git"
    ],
    "id": 1007865536,
    "html_url": "https://github.com/spack/spack/pull/26259",
    "assignees": [],
    "comments": 15
}