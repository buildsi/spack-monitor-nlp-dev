{
    "body": "### Overview\r\n\r\nThe goal of this PR is to make gitlab pipeline builds (especially build failures) more reproducible outside of the pipeline environment.  The two key changes here which aim to improve reproducibility are: \r\n\r\n1. Produce a `spack.lock` during pipeline generation which is passed to child jobs via artifacts.  This concretized environment is used both by generated child jobs as well as uploaded as an artifact to be used when reproducing the build locally.\r\n2. In the `spack ci rebuild` command, if a spec needs to be rebuilt from source, do this by generating and running an `install.sh` shell script which is then also uploaded as a job artifact to be run during local reproduction.  \r\n\r\nTo make it easier to take advantage of improved build reproducibility, this PR also adds a new subcommand, `spack ci reproduce-build`, which, given a url to job artifacts:\r\n\r\n- fetches and unzips the job artifacts to a local directory\r\n- looks for the generated pipeline yaml and parses it to find details about the job to reproduce\r\n- attempts to provide a copy of the same version of spack used in the ci build\r\n- if the ci build used a docker image, the command prints a `docker run` command you can run to get an interactive shell for reproducing the build\r\n\r\n#### Some highlights\r\n\r\nOne consequence of this change will be much smaller pipeline yaml files.  By encoding the concrete environment in a `spack.lock` and passing to child jobs via artifacts, we will no longer need to encode the concrete root of each spec and write it into the job variables, greatly reducing the size of the generated pipeline yaml.\r\n\r\nAdditionally `spack ci rebuild` output (stdout/stderr) is no longer internally redirected to a log file, so job output will appear directly in the gitlab job trace.  With debug logging turned on, this often results in log files getting truncated because they exceed the maximum amount of log output gitlab allows.  If this is a problem, you still have the option to `tee` command output to a file in the within the artifacts directory, as now each generated job exposes a `user_data` directory as an artifact, which you can fill with whatever you want in your custom job scripts.\r\n\r\nThere are some changes to be aware of in how pipelines should be set up after this PR:\r\n\r\n#### Pipeline generation\r\n\r\nBecause the pipeline generation job now writes a `spack.lock` artifact to be consumed by generated downstream jobs, `spack ci generate` takes a new option `--artifacts-root`, inside which it creates a `concrete_env` directory to place the lockfile.  This artifacts root directory is also where the `user_data` directory will live, in case you want to generate any custom artifacts.  If you do not provide `--artifacts-root`, the default is for it to create a `jobs_scratch_dir` within your `CI_PROJECT_DIR` (a gitlab predefined environment variable) or whatever is your current working directory if that variable isn't set. Here's the diff of the PR testing `.gitlab-ci.yml` taking advantage of the new option:\r\n\r\n```\r\n$ git diff develop..pipelines-reproducible-builds share/spack/gitlab/cloud_pipelines/.gitlab-ci.yml\r\ndiff --git a/share/spack/gitlab/cloud_pipelines/.gitlab-ci.yml b/share/spack/gitlab/cloud_pipelines/.gitlab-ci.yml\r\nindex 579d7b56f3..0247803a30 100644\r\n--- a/share/spack/gitlab/cloud_pipelines/.gitlab-ci.yml\r\n+++ b/share/spack/gitlab/cloud_pipelines/.gitlab-ci.yml\r\n@@ -28,10 +28,11 @@ default:\r\n     - cd share/spack/gitlab/cloud_pipelines/stacks/${SPACK_CI_STACK_NAME}\r\n     - spack env activate --without-view .\r\n     - spack ci generate --check-index-only\r\n+      --artifacts-root \"${CI_PROJECT_DIR}/jobs_scratch_dir\"\r\n       --output-file \"${CI_PROJECT_DIR}/jobs_scratch_dir/cloud-ci-pipeline.yml\"\r\n   artifacts:\r\n     paths:\r\n-      - \"${CI_PROJECT_DIR}/jobs_scratch_dir/cloud-ci-pipeline.yml\"\r\n+      - \"${CI_PROJECT_DIR}/jobs_scratch_dir\"\r\n   tags: [\"spack\", \"public\", \"medium\", \"x86_64\"]\r\n   interruptible: true\r\n```\r\n\r\nNotice how we replaced the specific pointer to the generated pipeline file with its containing folder, the same folder we passed as `--artifacts-root`.  This way anything in that directory (the generated pipeline yaml, as well as the concrete environment directory containing the `spack.lock`) will be uploaded as an artifact and available to the downstream jobs.\r\n\r\n#### Rebuild jobs\r\n\r\nRebuild jobs now must activate the concrete environment created by `spack ci generate` and provided via artifacts.  When the pipeline is generated, a directory called `concrete_environment` is created within the artifacts root directory, and this is where the `spack.lock` file is written to be passed to the generated rebuild jobs.  The artifacts root directory can be specified using the `--artifacts-root` option to `spack ci generate`, otherwise, it is assumed to be `$CI_PROJECT_DIR`.  The directory containing the concrete environment files (`spack.yaml` and `spack.lock`) is then passed to generated child jobs via the `SPACK_CONCRETE_ENV_DIR` variable in the generated pipeline yaml file.\r\n\r\nWhen you don't provide custom `script` sections in your `mappings` within the `gitlab-ci` section of your `spack.yaml`, the default behavior of rebuild jobs is now to change into `SPACK_CONCRETE_ENV_DIR` and activate that environment.   If you do provide custom rebuild scripts in your `spack.yaml`, be aware those scripts should do the same thing: assume `SPACK_CONCRETE_ENV_DIR` contains the concretized environment to activate.  No other changes to existing custom rebuild scripts should be required as a result of this PR. \r\n\r\nAs mentioned above, one key change made in this PR is the generation of the `install.sh` script by the rebuild jobs, as that same script is both run by the CI rebuild job as well as exported as an artifact to aid in subsequent attempts to reproduce the build outside of CI.  The generated `install.sh` script contains only a single `spack install` command with arguments computed by `spack ci rebuild`.  If the install fails, the job trace in gitlab will contain instructions on how to reproduce the build locally:\r\n\r\n```\r\nTo reproduce this build locally, run:\r\n  spack ci reproduce-build https://gitlab.next.spack.io/api/v4/projects/7/jobs/240607/artifacts [--working-dir <dir>]\r\nIf this project does not have public pipelines, you will need to first:\r\n  export GITLAB_PRIVATE_TOKEN=<generated_token>\r\n... then follow the printed instructions.\r\n```\r\n\r\nWhen run locally, the `spack ci reproduce-build` command shown above will download and process the job artifacts from gitlab, then print out instructions you  can copy-paste to run a local reproducer of the CI job.\r\n\r\nThis PR includes a few other changes to the way pipelines work, see the documentation on pipelines for more details.\r\n\r\nThis  PR erelies on \r\n~- [ ] #23194 to be able to refer to uninstalled specs by DAG hash~\r\nEDIT: that is going to take longer to come to fruition, so for now, we will continue to install specs represented by a concrete `spec.yaml` file on disk.\r\n- [x] #22657 to support install a single spec already present in the active, concrete environment ",
    "user": "scottwittenburg",
    "url": "https://api.github.com/repos/spack/spack/issues/22887",
    "updated_at": "2021-05-28 16:38:08",
    "created_at": "2021-04-08 23:14:31",
    "closed_at": "2021-05-28 16:38:08",
    "state": "closed",
    "title": "Pipelines: reproducible builds",
    "number": 22887,
    "milestone": null,
    "labels": [
        "radiuss"
    ],
    "id": 854009448,
    "html_url": "https://github.com/spack/spack/pull/22887",
    "assignees": [],
    "comments": 3
}