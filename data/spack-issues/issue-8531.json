{
    "body": "### Suggestion\r\n\r\nExtend Spack's compiler spec syntax by a reserved value that accommodates packages that _do not need a compiler_. For concreteness (ahem), let me suggest:\r\n\r\n```\r\n%none\r\n```\r\n\r\n* Spack seems to lack the concept of compiler-less packages, but it would appear to sorely be needed, see below and #7550 for several examples.\r\n* The reserved token is to have the property that ``foo%none`` satisfy a depency ``^foo%bar`` for an actual compiler.\r\n* The ``%none`` \"compiler\" should be pre-defined. This may lead to interesting conundrums for bootstrapping.\r\n* The concept is analogous to the ``noarch`` token in RPM packages, used to provide a single package that can be installed on different CPU architectures. Without ``noarch``, RPMs would have to be generated for each CPU architecture, equal in all aspects but metadata.\r\n\r\nAlternative tokens could perhaps be ``%`` (empty content),  ``%*``, ``%null``. I would think, however, that these are either more difficult to handle or more difficult to grep for.   ``%nocomp`` is also possible but seems redundant when ``%`` is accepted and read as the spec mini-language's sigil for \"compiler\".  Spack's Python-ness might suggest ``%None`` but that can be terribly misleading in use and debugging, and is also difficult to grep for.\r\n\r\n### Expected Result\r\n\r\nConsider the ``intel-mkl`` package, which provides libraries for linear algebra and FFT. It is distributed by its vendor as a binary package and can by design be used with different compilers.\r\n\r\nAssuming ``%none`` is implemented:\r\n\r\n1. Do:\r\n   ```\r\n   spack install intel-mkl\r\n   ```\r\n   Appropriate settings in the ``package.py`` code should treat this as being identical to:\r\n   ```\r\n   spack install intel-mkl%none\r\n   ```\r\n2. Then:\r\n   ```\r\n   spack install foo%gcc   ^intel-mkl\r\n   spack install foo%intel ^intel-mkl\r\n   ```\r\n   In both cases, the singular existing ``intel-mkl%none`` should be used.\r\n\r\n\r\n### Actual Result\r\n\r\nLeaving out ``%none``, the following happens:\r\n\r\n1. ``spack install intel-mkl`` installs ``intel-mkl`` for Spack's default compiler (either``%gcc``, or the one configured first in ``packages.yaml`` under ``all:``, ``compiler:``). So far, so good \u2013 seemingly.\r\n\r\n2. Regardless of Spack's default compiler, in at least one of the following commands\u00a0_a second version_ of ``intel-mkl`` will be installed implicitly and likely unexpected by the user, just to match the compiler of the calling package ``foo``\r\n   ```\r\n   spack install foo%intel ^intel-mkl\r\n   spack install foo%gcc   ^intel-mkl\r\n   ```\r\n   Moreover, the following would install _yet nother version_ of ``intel-mkl``:\r\n   ```\r\n   spack install foo%gcc@otherversion   ^intel-mkl\r\n   ```\r\n\r\n### Discussion\r\n\r\n* It is already possible to qualify a dependence that uses a different compiler. E.g., assuming ``%gcc`` is the default, the following would work:\r\n\r\n   ```\r\n   spack install intel-mkl\r\n   # installs as   intel-mkl%gcc@....\r\n\r\n   spack install foo   ^intel-mkl\r\n   # works as expected\r\n\r\n   spack install foo%intel  ^intel-mkl%gcc\r\n   spack install foo%gcc@otherversion  ^intel-mkl%gcc@installedversion\r\n   # also works\r\n   ```\r\n   However, this requires recurring effort from the user to _always_ qualify dependencies, and possibly later to re-identify them when inevitably forgotten.\r\n\r\n* Unfortunately, trying to cement, so to speak, a fixed compiler spec for an installed binary package in a ``providers:`` tag in ``packages.yaml`` does _not_ (yet?) work:\r\n\r\n  ``` yaml\r\n  packages:\r\n    all:\r\n      providers:\r\n        blas:      [intel-mkl%gcc, ]\r\n        lapack:    [intel-mkl%gcc, ]\r\n        scalapack: [intel-mkl%gcc, ]\r\n  ```\r\n  ```\r\n  $ spack spec hypre~mpi %intel \r\n  \u2026\r\n  hypre@2.14.0%intel@18.0.2~int64+internal-superlu~mpi+shared arch=linux-centos6-x86_64 \r\n      ^intel-mkl@2018.3.222%intel@18.0.2~ilp64+shared threads=none arch=linux-centos6-x86_64\r\n  ```\r\n  Note how still ``^intel-mkl%intel`` is called for.",
    "user": "mgsternberg",
    "url": "https://api.github.com/repos/spack/spack/issues/8531",
    "updated_at": "2020-02-21 12:54:01",
    "created_at": "2018-06-20 18:54:19",
    "closed_at": "None",
    "state": "open",
    "title": "Extend spec %compiler syntax to accommodate binary, script, and data packages",
    "number": 8531,
    "milestone": null,
    "labels": [
        "compilers",
        "proposal"
    ],
    "id": 334206917,
    "html_url": "https://github.com/spack/spack/issues/8531",
    "assignees": [],
    "comments": 3
}